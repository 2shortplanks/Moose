-------------------------------------------------------------------------------
 BUGS
------------------------------------------------------------------------------- 
 
mst: if I do "subtype 'Foo' => as 'Bar';" I get an empty condition and it dies

-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

- should handle some moose-specific options in &Moose::Meta::Class::create
  things like roles, and method modifiers (although those can probably be 
  ignored if i want to)

- type unions

Add support for doing it with Classes which do not have 
a type constraint yet created

- type intersections

Mostly just for Roles

- inherited slot specs

'does' can be added to,.. but not changed
(need type unions for this)

- proxy attributes

a proxied attribute is an attribute
which looks like an attribute, 
talks like an attribute, smells 
like an attribute,.. but if you 
look behind the curtain,.. its 
over there.. in that other object

(... probably be a custom metaclass)

- compile time extends

[00:39] 	sri	    but maybe a better syntax for compile time extends
[00:39] 	stevan	I have been pondering that actually
[00:39] 	sri	    use Moose extends => Foo::Bar
[00:40] 	stevan	I think now that we have the Sub::Exporter stuff 
                    in, that kinda thing should be pretty easy

nothingmuch notes that all the constructs should be supported in the entirety of the use clause:

    use Moose (
        has => foo (
            ....
        ),
    );

and that if this usage style is used nothing is exported to the namespace.

- default should dclone()

- subtype $anon_subtype => where { ... }

[22:56] 	stevan	sub mst_doesnt_like_to_type { (shift)->meta->attr->type_contstraint }
[22:57] 	mst	err
[22:57] 	stevan	:P
[22:57] 	stevan	are you wanting to reuse it or something?
[22:57] 	stevan	my $subtype = subtype 'Something' => where { ... };
[22:58] 	stevan	then you can do isa => $subtype 
[22:58] 	mst	but I can't subtype it again
[22:59] 	stevan	mst: ahhh... 
[22:59] 	mst	well, I can. but it suddenly gets very "long way round" ish
[23:00] 	stevan	my $constraint = Moose::Meta::TypeConstraint->new(
[23:00] 	stevan	            name       => $name || '__ANON__',
[23:00] 	stevan	            parent     => $parent,            
[23:00] 	stevan	            constraint => $check,       
[23:00] 	stevan	            message    => $message,    
[23:00] 	stevan	        );
[23:00] 	stevan	yeah thats kinda the long way
[23:00] 	stevan	mst: what would you like it to be?
[23:00] 	mst	$parent = find_type_constraint($parent) if defined $parent;
[23:00] 	mst	if $parent is already a type constraint
[23:00] 	mst	skip that bit
[23:00] 	stevan	hmm
[23:00] 	mst	should be all you need to change
[23:00] 	stevan	yeah
[23:01] 	stevan	so you can then say 
[23:01] 	stevan	subtype $anon => where { ... };
[23:01] 	mst	right
[23:01] 	stevan	ok

- method keyword

[23:37] 	mst	more seriously, I'd still like a "method" keyword or something
[23:37] 	mst	method 'foo' => sub { ... };
[23:38] 	stevan	what would it do more than sub foo { ... }?
[23:39] 	stevan	I would like multimethods actually
[23:39] 	mst	almost exactly nothing, to begin with
[23:39] 	stevan	but thats just cause I love CLOS and am reading a book on Dylan now
[23:40] 	stevan	keyword squating :)
[23:40] 	mst	but if we need to hook stuff later it's bloody handy to already have people writing it that way
[23:40] 	mst	right
...
[23:49] 	mst	oh, also: method 'has' => sub { ... } could squelch the redefine warning
  
- local coerce

[13:16] 	mst	stevan: slight problem with coerce
[13:16] 	mst	I only get to declare it once
[13:17] 	mst	so if I'm trying to declare it cast-style per-source-class rather than per-target-class
[13:17] 	mst	I am extremely screwed
[13:17] 	stevan	yes
[13:17] 	stevan	they are not class specific 
[13:18] 	stevan	they are attached to the type constraint itself
[13:18] 	*	stevan ponders anon-coercion-metaobjects
[13:18] 	mst	yes, that's fine
[13:19] 	mst	but when I declare a class
[13:19] 	mst	I want to be able to say "this class coerces to X type via <this>"
[13:19] 	stevan	yeah something like that
[13:19] 	stevan	oh,.. hmm
[13:20] 	stevan	sort of like inflate/deflate?
[13:20] 	stevan	around the accessors?
[13:25] 	*	bluefeet has quit (Remote host closed the connection)
[13:27] 	mst	no
[13:27] 	mst	nothing like that
[13:27] 	mst	like a cast
[13:31] 	mst	stevan: $obj->foo($bar); where 'foo' expects a 'Foo' object
[13:31] 	mst	stevan: is effectively <Foo>$bar, right?
[13:32] 	mst	stevan: I want to be able to say in package Bar
[13:32] 	mst	stevan: coerce_to 'Foo' via { ... };
[13:32] 	mst	etc.
[13:53] 	stevan	hmm  
  
  
-------------------------------------------------------------------------------
TO PONDER
-------------------------------------------------------------------------------

- Moose "strict" mode

use Moose 'strict'; This would allow us to have all sort of expensive tests
which can be turned off in prod.     
        
- Moose::Philosophy.pod

To explain Moose from a very high level

- moosedoc

We certainly have enough meta-information to make pretty complete POD docs.
        
        
        
